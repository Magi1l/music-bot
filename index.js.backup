// 환경 변수 로드
require('dotenv').config();

const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const axios = require('axios');
const cheerio = require('cheerio');
const cron = require('node-cron');
const { DisTube } = require('distube');
const { SpotifyPlugin } = require('@distube/spotify');

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent
  ]
});

// DisTube 초기화 (스포티파이 플러그인 추가)
const distube = new DisTube(client, {
  plugins: [new SpotifyPlugin()],
  searchSongs: 5, // 검색 결과 수
  searchCooldown: 30, // 검색 쿨다운 (초)
  leaveOnEmpty: true, // 채널이 비어있을 때 나가기
  leaveOnFinish: false, // 재생 완료 후 나가지 않음
  leaveOnStop: false // 정지 시 나가지 않음
});

// 웹사이트 크롤링 설정 저장소
const websiteConfig = new Map();

// 환경 변수 설정
const { DISCORD_TOKEN, YOUTUBE_COOKIE } = process.env;

// 웹사이트 크롤링 함수
async function checkWebsite(guildId) {
  const config = websiteConfig.get(guildId);
  if (!config) return;

  try {
    const response = await axios.get(config.url);
    const $ = cheerio.load(response.data);
    const html = response.data;
    
    // 게시글 요소 자동 탐색
    const posts = [];
    const postElements = $('div, article, section, li').toArray();
    
    for (const el of postElements) {
      const $el = $(el);
      
      // 게시글이 아닌 요소 필터링
      if (!isPostElement($el)) continue;
      
      // 게시글 정보 추출
      const post = {
        id: getPostId($el),
        title: getPostTitle($el),
        link: getPostLink($el),
        date: getPostDate($el),
        image: getPostImage($el)
      };
      
      if (post.title && post.link) {
        posts.push(post);
      }
    }

    function isPostElement($el) {
      // 게시글이 아닌 요소 필터링
      const text = $el.text().trim();
      return text.length > 0 && !text.includes('페이지') && !text.includes('검색');
    }

    function getPostId($el) {
      return $el.attr('id') || $el.attr('data-id') || $el.attr('data-post-id') || $el.attr('data-article-id') || Date.now().toString();
    }

    function getPostTitle($el) {
      // 제목을 찾는 여러 방법 시도
      const titleSelectors = [
        'h1, h2, h3, h4, h5, h6',
        '.title, .post-title, .article-title',
        'a[href]:contains("read")',
        'a[href]:contains("view")'
      ];
      
      for (const selector of titleSelectors) {
        const title = $el.find(selector).text().trim();
        if (title) return title;
      }
      return '';
    }

    function getPostLink($el) {
      // 링크를 찾는 여러 방법 시도
      const linkSelectors = [
        'a[href]',
        'button[href]',
        '[data-href]',
        '[data-link]'
      ];
      
      for (const selector of linkSelectors) {
        const link = $el.find(selector).attr('href');
        if (link) return link.startsWith('http') ? link : config.url + link;
      }
      return '';
    }

    function getPostDate($el) {
      // 날짜를 찾는 여러 방법 시도
      const dateSelectors = [
        '.date, .post-date, .article-date',
        'time',
        'span[data-date]',
        'div[data-date]'
      ];
      
      for (const selector of dateSelectors) {
        const date = $el.find(selector).text().trim();
        if (date) return date;
      }
      return '';
    }

    function getPostImage($el) {
      // 이미지를 찾는 여러 방법 시도
      const imageSelectors = [
        'img',
        '[data-image]',
        '[data-src]',
        '[style*="background-image"]'
      ];
      
      for (const selector of imageSelectors) {
        const $img = $el.find(selector);
        if ($img.length > 0) {
          const src = $img.attr('src') || 
                    $img.attr('data-image') || 
                    $img.attr('data-src') || 
                    $img.css('background-image').replace(/url\("|"\)/g, '');
          if (src) return src.startsWith('http') ? src : config.url + src;
        }
      }
      return null;
    }

    if (posts.length > 0 && posts[0].id !== config.lastPostId) {
      config.lastPostId = posts[0].id;
      
      const channel = client.channels.cache.get(config.channelId);
      if (channel) {
        const post = posts[0];
        const embed = new EmbedBuilder()
          .setTitle('새로운 게시글이 올라왔어요!')
          .setDescription(`[${post.title}](${post.link})`)
          .addFields(
            { name: '날짜', value: post.date || '미지정', inline: true }
          )
          .setColor('Random');

        // 이미지나 비디오가 있을 경우 Embed에 추가
        if (post.image) {
          embed.setThumbnail(post.image);
        }

        // 비디오가 있을 경우 URL 추가
        if (post.link.includes('youtube') || post.link.includes('vimeo')) {
          embed.addFields({
            name: '비디오 링크',
            value: `[클릭하여 시청](${post.link})`,
            inline: true
          });
        }

        await channel.send({ embeds: [embed] });
      }
    }
  } catch (error) {
    console.error(`서버 ${guildId}의 웹사이트 크롤링 중 오류:`, error);
  }
}

// 주기적인 크롤링 설정
function setupCron(guildId) {
  const config = websiteConfig.get(guildId);
  if (config && config.cron) {
    config.cron.destroy();
  }

  if (config && config.url && config.channelId) {
    config.cron = cron.schedule(`*/${Math.floor(config.interval / 60000)} * * * *`, () => checkWebsite(guildId));
  }
}

const nowPlayingMessages = new Map();
// 검색 결과 임시 저장을 위한 캐시
const searchResultsCache = new Map();

client.once('ready', () => {
  console.log(`${client.user.tag} 온라인!`);
  registerCommands();
});

// 슬래시 명령어 등록
async function registerCommands() {
  try {
    console.log('명령어 등록 시작...');
    
    // 명령어 정의
    const commands = [
      // 웹사이트 크롤링 관련 명령어
      {
        name: '웹사이트설정',
        description: '웹사이트 크롤링 설정을 저장합니다.',
        options: [
          {
            name: 'url',
            description: '크롤링할 웹사이트 URL',
            type: 3,
            required: true
          },
          {
            name: '채널',
            description: '알림을 보낼 채널',
            type: 7,
            required: true
          },
          {
            name: '간격',
            description: '크롤링 간격 (분)',
            type: 4,
            required: false,
            minValue: 1,
            maxValue: 1440
          }
        ]
      },
      {
        name: '웹사이트조회',
        description: '현재 설정된 웹사이트 설정을 확인합니다.'
      },
      {
        name: '웹사이트삭제',
        description: '웹사이트 크롤링 설정을 삭제합니다.'
      },
      // 음악 관련 명령어
      {
        name: 'play',
        description: '음악을 재생합니다.',
        options: [
          {
            name: 'query',
            description: '검색어 또는 URL',
            type: 3,
            required: true
          }
        ]
      },
      {
        name: 'skip',
        description: '현재 재생 중인 곡을 건너뜁니다.'
      },
      {
        name: 'queue',
        description: '재생 대기열을 확인합니다.'
      },
      {
        name: 'stop',
        description: '재생을 중지합니다.'
      }
    ];

    // 전역 명령어로 등록 (모든 서버에 적용)
    console.log(`${commands.length}개의 명령어를 등록합니다...`);
    await client.application.commands.set(commands);
    console.log('명령어 등록 완료!');
  } catch (error) {
    console.error('명령어 등록 중 오류:', error);
  }
}
run = "npm start"

// 슬래시 명령어 처리
client.on('interactionCreate', async interaction => {
  if (!interaction.isCommand()) return;

  const { commandName, options } = interaction;

  // 웹사이트 크롤링 관련 명령어 처리
  switch (commandName) {
    case '웹사이트설정': {
      // 관리자 권한 확인
      if (!interaction.member.permissions.has('Administrator')) {
        return interaction.reply({ content: '이 명령어는 관리자만 사용할 수 있습니다.', ephemeral: true });
      }

      const url = options.getString('url');
      const channel = options.getChannel('채널');
      const interval = options.getInteger('간격') || 5;

      if (!channel.isText()) {
        return interaction.reply({ content: '채널은 텍스트 채널이어야 합니다.', ephemeral: true });
      }

      websiteConfig.set(interaction.guildId, {
        url,
        channelId: channel.id,
        interval: interval * 60000, // 분을 밀리초로 변환
        lastPostId: null,
        cron: null
      });

      setupCron(interaction.guildId);
      return interaction.reply({ content: `웹사이트 크롤링이 설정되었습니다!\nURL: ${url}\n알림 채널: ${channel.name}\n크롤링 간격: ${interval}분`, ephemeral: true });
    }
    case '웹사이트조회': {
      // 관리자 권한 확인
      if (!interaction.member.permissions.has('Administrator')) {
        return interaction.reply({ content: '이 명령어는 관리자만 사용할 수 있습니다.', ephemeral: true });
      }

      const config = websiteConfig.get(interaction.guildId);
      if (!config) {
        return interaction.reply({ content: '설정된 웹사이트가 없습니다.', ephemeral: true });
      }
      return interaction.reply({
        content: `현재 설정:\nURL: ${config.url}\n알림 채널: <#${config.channelId}>\n크롤링 간격: ${(config.interval / 60000)}분`,
        ephemeral: true
      });
    }
    break;
  case 'play':
    try {
      const query = interaction.options.getString('query');
      const member = interaction.member;
      if (!member.voice.channelId) return interaction.reply({ content: '음성 채널에 먼저 들어가세요!', ephemeral: true });

      // 음성 채널 객체 가져오기
      const voiceChannel = interaction.guild.channels.cache.get(member.voice.channelId);
      if (!voiceChannel) {
        return interaction.reply({ content: '음성 채널을 찾을 수 없습니다.', ephemeral: true });
      }
      
      console.log(`음성 채널 정보: ${voiceChannel.name}, 타입: ${voiceChannel.type}`);
      
      // 검색 실행
      // 응답을 지연하고 사용자에게 처리 중임을 표시
      await interaction.deferReply({ ephemeral: false }).catch(err => {
        console.error('인터렉션 지연 오류:', err);
      });
      
      try {
        // 직접 재생 시도 - DisTube 5.0.7에서는 이 방식을 사용
        try {
          // 유튜브 검색
          const youtubeResults = await distube.play(voiceChannel, query, {
            member: member,
            textChannel: interaction.channel,
            skip: false,
            position: 1, // 현재 재생중인 곳 다음에 추가
            pause: true, // 일단 일시정지
            metadata: { source: 'youtube' }
          });
          
          // 스포티파이 검색 (스포티파이 URL이 아니면 검색어에 spotify: 접두어 추가)
          const spotifyQuery = query.includes('spotify.com') ? query : `spotify:${query}`;
          const spotifyResults = await distube.play(voiceChannel, spotifyQuery, {
            member: member,
            textChannel: interaction.channel,
            skip: false,
            position: 2, // 유튜브 검색 결과 다음에 추가
            pause: true, // 일단 일시정지
            metadata: { source: 'spotify' }
          }).catch(err => {
            console.log('스포티파이 검색 오류 (무시해도 됨):', err.message);
            return null; // 스포티파이 검색 실패는 무시하고 계속 진행
          });
          
          // 큐 가져오기
          const queue = distube.getQueue(interaction.guild.id);
          if (!queue) {
            return interaction.editReply({ content: '큐를 찾을 수 없습니다. 노래 재생에 문제가 발생했습니다.' });
          }
          
          // 큐에서 검색 결과 가져오기
          const searchResults = queue.songs.slice(1); // 현재 재생중인 곱 제외
          
          // 큐 초기화 (검색만 위한 것이었으니 지우기)
          queue.stop();
          
          // 검색 결과가 없을 경우
          if (!searchResults || searchResults.length === 0) {
            return interaction.editReply({ content: '검색 결과가 없습니다. 다른 검색어를 사용해보세요.' });
          }
        } catch (playError) {
          console.error('재생 시도 중 오류:', playError);
          return interaction.editReply({ content: `노래 재생 중 오류가 발생했습니다: ${playError.message}` });
        }
        
        // 검색 결과 분류
        const youtubeResults = searchResults.filter(song => !song.metadata || song.metadata.source !== 'spotify');
        const spotifyResults = searchResults.filter(song => song.metadata && song.metadata.source === 'spotify');
        
        // 유튜브 검색 결과 표시
        const youtubeEmbed = new EmbedBuilder()
          .setTitle('📺 YouTube 검색 결과')
          .setDescription('아래 버튼을 클릭하여 노래를 선택해주세요.')
          .setColor('#FF0000'); // YouTube 빨간색
        
        // 유튜브 검색 결과를 필드로 추가
        youtubeResults.slice(0, 5).forEach((result, index) => {
          youtubeEmbed.addFields({
            name: `${index + 1}. ${result.name}`,
            value: `재생 시간: ${msToTime(result.duration)} | [YouTube 링크](${result.url})`,
            inline: false
          });
        });
        
        // 스포티파이 검색 결과 표시
        const spotifyEmbed = new EmbedBuilder()
          .setTitle('🎵 Spotify 검색 결과')
          .setDescription('아래 버튼을 클릭하여 노래를 선택해주세요.')
          .setColor('#1DB954'); // Spotify 초록색
        
        // 스포티파이 검색 결과가 있으면 필드로 추가
        if (spotifyResults.length > 0) {
          spotifyResults.slice(0, 5).forEach((result, index) => {
            spotifyEmbed.addFields({
              name: `${index + 1}. ${result.name}`,
              value: `재생 시간: ${msToTime(result.duration)} | 아티스트: ${result.uploader?.name || '알 수 없음'}`,
              inline: false
            });
          });
        } else {
          spotifyEmbed.setDescription('스포티파이 검색 결과가 없습니다.');
        }
        
        // 유튜브 선택 버튼 생성
        const youtubeRow = new ActionRowBuilder().addComponents(
          new ButtonBuilder().setCustomId('youtube_0').setLabel('1').setStyle(ButtonStyle.Danger),
          new ButtonBuilder().setCustomId('youtube_1').setLabel('2').setStyle(ButtonStyle.Danger),
          new ButtonBuilder().setCustomId('youtube_2').setLabel('3').setStyle(ButtonStyle.Danger),
          new ButtonBuilder().setCustomId('youtube_3').setLabel('4').setStyle(ButtonStyle.Danger),
          new ButtonBuilder().setCustomId('youtube_4').setLabel('5').setStyle(ButtonStyle.Danger)
        );
        
        // 스포티파이 선택 버튼 생성
        const spotifyRow = new ActionRowBuilder().addComponents(
          new ButtonBuilder().setCustomId('spotify_0').setLabel('1').setStyle(ButtonStyle.Success),
          new ButtonBuilder().setCustomId('spotify_1').setLabel('2').setStyle(ButtonStyle.Success),
          new ButtonBuilder().setCustomId('spotify_2').setLabel('3').setStyle(ButtonStyle.Success),
          new ButtonBuilder().setCustomId('spotify_3').setLabel('4').setStyle(ButtonStyle.Success),
          new ButtonBuilder().setCustomId('spotify_4').setLabel('5').setStyle(ButtonStyle.Success)
        );
        
        // 스포티파이 결과가 없으면 버튼 비활성화
        if (spotifyResults.length === 0) {
          spotifyRow.components.forEach(button => button.setDisabled(true));
        }
        
        // 임시 저장
        searchResultsCache.set(interaction.guild.id, {
          youtubeResults,
          spotifyResults,
          voiceChannel,
          member: interaction.member,
          timestamp: Date.now()
        });
        
        // 10분 후 캐시 삭제 (자동 정리)
        setTimeout(() => {
          if (searchResultsCache.has(interaction.guild.id)) {
            searchResultsCache.delete(interaction.guild.id);
          }
        }, 10 * 60 * 1000);
        
        // 유튜브 결과와 스포티파이 결과 모두 표시
        await interaction.editReply({
          embeds: [youtubeEmbed, spotifyEmbed],
          components: [youtubeRow, spotifyRow]
        });
        
      } catch (error) {
        console.error('노래 검색 중 오류:', error);
        await interaction.editReply(`노래 검색 중 오류가 발생했습니다: ${error.message}`);
      }
    } catch (error) {
      console.error('명령어 처리 중 오류:', error);
      try {
        await interaction.editReply('명령어 처리 중 오류가 발생했습니다.');
        await interaction.reply({ content: `명령어 실행 중 오류가 발생했습니다: ${error.message}`, ephemeral: true });
      } catch {
        // 이미 응답한 경우
        try {
          await interaction.editReply({ content: `명령어 실행 중 오류가 발생했습니다: ${error.message}` });
        } catch {
          console.error('인터렉션 응답 오류');
        }
      }
    }
    break;
  case 'skip':
    try {
      const queue = distube.getQueue(interaction.guild.id);
      if (!queue) return interaction.reply({ content: '재생 중인 곡이 없습니다.', ephemeral: true });

      queue.skip();
      interaction.reply({ content: '다음 곡으로 스킵했습니다!', ephemeral: true });
    } catch (error) {
      console.error('명령어 실행 중 오류:', error);
      await interaction.reply({ content: '명령어 실행 중 오류가 발생했습니다.', ephemeral: true });
    }
    break;
  case 'queue':
    try {
      const queue = distube.getQueue(interaction.guild.id);
      if (!queue || queue.songs.length === 0) {
        return interaction.reply({ content: '재생 목록이 비어있습니다.', ephemeral: true });
      }

      const embed = new EmbedBuilder()
        .setTitle('재생 목록')
        .setDescription(queue.songs.map((song, index) => 
          `${index + 1}. [${song.name}](${song.url})`
        ).join('\n'))
        .setColor('Random');

      interaction.reply({ embeds: [embed] });
    } catch (error) {
      console.error('명령어 실행 중 오류:', error);
      await interaction.reply({ content: '명령어 실행 중 오류가 발생했습니다.', ephemeral: true });
    }
    break;
  case 'stop':
    try {
      const queue = distube.getQueue(interaction.guild.id);
      if (!queue) return interaction.reply({ content: '재생 중인 곡이 없습니다.', ephemeral: true });

      queue.stop();
      interaction.reply({ content: '재생을 중지했습니다!', ephemeral: true });
    } catch (error) {
      console.error('명령어 실행 중 오류:', error);
      await interaction.reply({ content: '명령어 실행 중 오류가 발생했습니다.', ephemeral: true });
    }
    break;
  }
});

// 버튼 인터렉션 처리
client.on('interactionCreate', async interaction => {
  if (!interaction.isButton()) return;
  
  try {
    // 검색 결과 선택 버튼 처리
    if (interaction.customId.startsWith('youtube_') || interaction.customId.startsWith('spotify_')) {
      // 인터렉션 업데이트를 디퍼하여 사용자에게 버튼이 처리중임을 표시
      await interaction.deferUpdate().catch(console.error);
      
      const parts = interaction.customId.split('_');
      const source = parts[0]; // youtube 또는 spotify
      const index = parseInt(parts[1]);
      
      // 캁션 데이터 가져오기
      const cacheData = searchResultsCache.get(interaction.guild.id);
      if (!cacheData) {
        return interaction.followUp({ content: '검색 정보가 만료되었습니다. 다시 검색해주세요.', ephemeral: true });
      }
      
      const { youtubeResults, spotifyResults, voiceChannel, member } = cacheData;
      
      // 소스에 따라 결과 선택
      let selectedSong;
      if (source === 'youtube') {
        if (!youtubeResults || !youtubeResults[index]) {
          return interaction.followUp({ content: '선택한 YouTube 노래 정보를 찾을 수 없습니다.', ephemeral: true });
        }
        selectedSong = youtubeResults[index];
      } else { // spotify
        if (!spotifyResults || !spotifyResults[index]) {
          return interaction.followUp({ content: '선택한 Spotify 노래 정보를 찾을 수 없습니다.', ephemeral: true });
        }
        selectedSong = spotifyResults[index];
      }
      
      try {
        // 선택한 노래 재생
        distube.play(voiceChannel, selectedSong.url, {
          member: member,
          textChannel: interaction.channel
        });
        
        // 성공 메세지
        const embed = new EmbedBuilder()
          .setTitle('재생 시작')
          .setDescription(`[${selectedSong.name}](${selectedSong.url})`)
          .addFields(
            { name: '재생 시간', value: msToTime(selectedSong.duration), inline: true }
          )
          .setThumbnail(selectedSong.thumbnail)
          .setColor('Random');
        
        // 원래 메세지 업데이트 (버튼 비활성화 및 성공 메세지 표시)
        await interaction.update({ embeds: [embed], components: [] });
        
        // 추가 정보 메세지
        await interaction.followUp({ content: `\u25b6\ufe0f **${selectedSong.name}** 재생을 시작합니다.`, ephemeral: true });
      } catch (error) {
        console.error('노래 재생 중 오류:', error);
        try {
          await interaction.followUp({ content: `노래 재생 중 오류가 발생했습니다: ${error.message}`, ephemeral: true });
        } catch (followUpError) {
          console.error('오류 메세지 전송 실패:', followUpError);
          try {
            await interaction.update({ content: `노래 재생 중 오류가 발생했습니다: ${error.message}`, components: [] });
          } catch (updateError) {
            console.error('인터렉션 업데이트 실패:', updateError);
          }
        }
      }
      
      return;
    }
    
    // 기존 재생 관련 버튼 처리
    const queue = distube.getQueue(interaction.guild.id);
    if (!queue) return interaction.reply({ content: '재생 중인 곡이 없습니다.', ephemeral: true });

    switch (interaction.customId) {
      case 'stop':
        queue.stop();
        await interaction.reply({ content: '\u23f9\ufe0f 재생을 중지했습니다.', ephemeral: true });
        break;
      case 'repeat':
        queue.setRepeatMode(queue.repeatMode === 0 ? 1 : 0);
        await interaction.reply({ content: queue.repeatMode === 1 ? '\ud83d\udd01 반복 재생 ON' : '\ud83d\udd01 반복 재생 OFF', ephemeral: true });
        break;
      case 'queue':
        if (!queue.songs.length) return interaction.reply({ content: '대기열이 비어있어요.', ephemeral: true });
        const queueList = queue.songs.map((song, i) => `${i + 1}. ${song.name}`).join('\n');
        await interaction.reply({ content: `**대기열**\n${queueList}`, ephemeral: true });
        break;
    }
  } catch (error) {
    console.error('버튼 인터렉션 중 오류:', error);
    try {
      await interaction.reply({ content: '버튼 처리 중 오류가 발생했습니다.', ephemeral: true });
    } catch {
      try {
        await interaction.editReply({ content: '버튼 처리 중 오류가 발생했습니다.' });
      } catch {
        console.error('인터렉션 응답 오류');
      }
    }
  }
});
        // 추가 정보 메세지
        await interaction.followUp({ content: `\u25b6\ufe0f **${selectedSong.name}** 재생을 시작합니다.`, ephemeral: true });
      } catch (error) {
        console.error('노래 재생 중 오류:', error);
        try {
          await interaction.followUp({ content: `노래 재생 중 오류가 발생했습니다: ${error.message}`, ephemeral: true });
        } catch (followUpError) {
          console.error('오류 메세지 전송 실패:', followUpError);
          try {
            await interaction.update({ content: `노래 재생 중 오류가 발생했습니다: ${error.message}`, components: [] });
          } catch (updateError) {
            console.error('인터렉션 업데이트 실패:', updateError);
          }
        }
      }
      
      return;
    }
    
    // 기존 재생 관련 버튼 처리
    const queue = distube.getQueue(interaction.guild.id);
    if (!queue) return interaction.reply({ content: '재생 중인 곡이 없습니다.', ephemeral: true });

    switch (interaction.customId) {
      case 'stop':
        queue.stop();
        await interaction.reply({ content: '⏹️ 재생을 중지했습니다.', ephemeral: true });
        break;
      case 'repeat':
        queue.setRepeatMode(queue.repeatMode === 0 ? 1 : 0);
        await interaction.reply({ content: queue.repeatMode === 1 ? '🔁 반복 재생 ON' : '🔁 반복 재생 OFF', ephemeral: true });
        break;
      case 'queue':
        if (!queue.songs.length) return interaction.reply({ content: '대기열이 비어있어요.', ephemeral: true });
        const queueList = queue.songs.map((song, i) => `${i + 1}. ${song.name}`).join('\n');
        await interaction.reply({ content: `**대기열**\n${queueList}`, ephemeral: true });
        break;
    }
  } catch (error) {
    console.error('버튼 인터렉션 중 오류:', error);
    try {
      await interaction.reply({ content: '버튼 처리 중 오류가 발생했습니다.', ephemeral: true });
    } catch {
      try {
        await interaction.editReply({ content: '버튼 처리 중 오류가 발생했습니다.' });
      } catch {
        console.error('인터렉션 응답 오류');
      }
    }
  }
});

// 노래 시작 시 메세지 표시 및 버튼 생성
distube.on('playSong', async (queue, song) => {
  console.log('노래 재생 시작:', song.name);
  const channel = client.channels.cache.get(queue.textChannelId);
  if (!channel) return console.log('텍스트 채널을 찾을 수 없습니다.');

  try {
    // 이전 메세지 삭제
    if (nowPlayingMessages.has(queue.guild.id)) {
      try {
        const oldMsg = await channel.messages.fetch(nowPlayingMessages.get(queue.guild.id));
        await oldMsg.delete().catch(() => {});
      } catch (err) {
        console.log('이전 메세지 삭제 중 오류:', err);
      }
    }

    const embed = new EmbedBuilder()
      .setTitle('🎵 현재 재생 중')
      .setDescription(`[${song.name}](${song.url})`)
      .addFields(
        { name: '길이', value: msToTime(song.duration), inline: true },
        { name: '요청자', value: `<@${song.member.id}>`, inline: true }
      )
      .setThumbnail(song.thumbnail)
      .setColor('Random');

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder().setCustomId('stop').setLabel('중지').setStyle(ButtonStyle.Danger).setEmoji('⏹️'),
      new ButtonBuilder().setCustomId('repeat').setLabel('반복').setStyle(ButtonStyle.Primary).setEmoji('🔁'),
      new ButtonBuilder().setCustomId('queue').setLabel('대기열').setStyle(ButtonStyle.Secondary).setEmoji('📜')
    );

    const msg = await channel.send({ embeds: [embed], components: [row] });
    nowPlayingMessages.set(queue.guild.id, msg.id);
    console.log('재생 정보 메세지 전송 완료');
  } catch (error) {
    console.error('트랙 시작 알림 중 오류:', error);
  }
});

// 재생 종료 시 메세지 삭제
distube.on('finish', async (queue) => {
  console.log('재생 종료 이벤트 발생');
  const channel = client.channels.cache.get(queue.textChannelId);
  if (!channel) return console.log('텍스트 채널을 찾을 수 없습니다.');
  
  if (nowPlayingMessages.has(queue.guild.id)) {
    try {
      const msg = await channel.messages.fetch(nowPlayingMessages.get(queue.guild.id));
      await msg.delete().catch(() => {});
      nowPlayingMessages.delete(queue.guild.id);
    } catch (err) {
      console.log('메세지 삭제 중 오류:', err);
    }
  }

  try {
    await channel.send('모든 노래 재생이 끝났어요!');
  } catch (error) {
    console.error('재생 종료 알림 중 오류:', error);
  }
});

// 오류 이벤트 처리
distube.on('error', (channel, error) => {
  console.error('음악 재생 오류:', error);
  if (channel) channel.send(`음악 재생 중 오류가 발생했습니다: ${error.toString().slice(0, 1900)}`);
});

// 검색 이벤트 처리
distube.on('searchResult', (message, results) => {
  console.log('검색 결과:', results.length);
});

// 검색 취소 이벤트 처리
distube.on('searchCancel', (message) => {
  console.log('검색이 취소되었습니다.');
  message.channel.send('검색이 취소되었습니다.');
});

// 연결 이벤트 처리
distube.on('connectionError', (queue, error) => {
  console.error('연결 오류:', error);
  queue.textChannel.send(`연결 오류가 발생했습니다: ${error.toString().slice(0, 1900)}`);
});

// 시간 변환 함수
function msToTime(ms) {
  const sec = Math.floor((ms / 1000) % 60);
  const min = Math.floor((ms / (1000 * 60)) % 60);
  const hr = Math.floor(ms / (1000 * 60 * 60));
  return hr ? `${hr}:${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}` : `${min}:${sec.toString().padStart(2, '0')}`;
}

// 에러 처리
process.on('unhandledRejection', error => {
  console.error('미처리된 프로미스 거부:', error);
});

let lastPostId = null;

// 웹사이트 크롤링 함수
async function checkWebsite() {
  try {
    const response = await axios.get(process.env.WEBSITE_URL);
    const $ = cheerio.load(response.data);
    
    // 게시글 선택자 수정 필요 (사이트에 맞게)
    const posts = $('div.post').map((i, el) => ({
      id: $(el).attr('id'),
      title: $(el).find('h3.title').text().trim(),
      link: $(el).find('a').attr('href'),
      date: $(el).find('.date').text().trim()
    })).get();

    if (posts.length > 0) {
      const newestPost = posts[0];
      if (lastPostId !== newestPost.id) {
        lastPostId = newestPost.id;
        
        const channel = client.channels.cache.get(process.env.CHANNEL_ID);
        if (channel) {
          const embed = new EmbedBuilder()
            .setTitle('새로운 게시글이 올라왔어요!')
            .setDescription(`[${newestPost.title}](${newestPost.link})`)
            .addFields(
              { name: '날짜', value: newestPost.date, inline: true }
            )
            .setColor('Random');

          await channel.send({ embeds: [embed] });
        }
      }
    }
  } catch (error) {
    console.error('웹사이트 크롤링 중 오류:', error);
  }
}

// 주기적인 크롤링 설정
if (process.env.WEBSITE_URL && process.env.CHANNEL_ID) {
  cron.schedule(`*/${Math.floor(process.env.CHECK_INTERVAL / 60000)} * * * *`, checkWebsite);
  console.log('웹사이트 크롤링이 시작되었습니다.');
}

// 토큰 확인
console.log('토큰 확인 (처음 몇 자리만):', process.env.DISCORD_TOKEN ? process.env.DISCORD_TOKEN.substring(0, 10) + '...' : '토큰이 없습니다');

// 봇 로그인
client.login(process.env.DISCORD_TOKEN).catch(error => {
  console.error('로그인 오류:', error.message);
});
